require 'socket'

# Provides basic, single threaded HTTP server functionality.
module Wpxf::Net::HttpServer
  include Wpxf

  def initialize
    super

    register_options([
      StringOption.new(
        name: 'http_server_bind_address',
        desc: 'Address to bind the HTTP server to',
        default: '0.0.0.0',
        required: true
      ),
      PortOption.new(
        name: 'http_server_bind_port',
        desc: 'Port for the HTTP server to listen on',
        default: 80,
        required: true
      )
    ])

    @http_server_kill_switch = false
  end

  def http_server_bind_address
    normalized_option_value('http_server_bind_address')
  end

  def http_server_bind_port
    normalized_option_value('http_server_bind_port')
  end

  def on_http_request(path, headers)
  end

  def start_http_server
    server = TCPServer.new(http_server_bind_address, http_server_bind_port)
    emit_info "Started HTTP server on #{http_server_bind_address}:"\
              "#{http_server_bind_port}"

    begin
      loop do
        socket = server.accept

        response = handle_incoming_http_request(socket)
        if response
          socket.print "HTTP/1.1 200 OK\r\n"\
                       "Content-Type: text/plain\r\n"\
                       "Content-Length: #{response.bytesize}\r\n"\
                       "Connection: close\r\n"
          socket.print "\r\n"
          socket.print response
        end

        socket.close
        break if @http_server_kill_switch
      end
    rescue SignalException
      emit_warning 'Caught kill signal', true
    end

    emit_info 'HTTP server stopped'
    @http_server_kill_switch = false
  end

  def stop_http_server
    emit_info 'Stopping HTTP server...', true
    @http_server_kill_switch = true
  end

  private

  def handle_incoming_http_request(socket)
    request = socket.gets
    if request
      emit_info "Incoming HTTP request: #{request}", true

      headers = ''
      while (line = socket.gets) != "\r\n"
        headers += line
        emit_info line, true
      end

      headers = Hash[headers.each_line.map { |l| l.chomp.split(': ', 2) }]
      path = request.gsub(/^[A-Za-z]+\s(.+?)\s.*$/, '\1')

      # Dispatch parsed data to the callback in the module.
      on_http_request(path, headers)
    end
  end
end
