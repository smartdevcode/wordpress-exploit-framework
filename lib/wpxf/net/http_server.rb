require 'cgi'
require 'socket'

# Provides basic, single threaded HTTP server functionality.
module Wpxf::Net::HttpServer
  include Wpxf

  def initialize
    super

    register_options([
      StringOption.new(
        name: 'http_server_bind_address',
        desc: 'Address to bind the HTTP server to',
        default: '0.0.0.0',
        required: true
      ),
      PortOption.new(
        name: 'http_server_bind_port',
        desc: 'Port for the HTTP server to listen on',
        default: 80,
        required: true
      )
    ])

    @http_server_kill_switch = false
  end

  def http_server_bind_address
    normalized_option_value('http_server_bind_address')
  end

  def http_server_bind_port
    normalized_option_value('http_server_bind_port')
  end

  def on_http_request(path, params, headers)
  end

  def js_ajax_download
    File.read(File.join(Wpxf.data_directory, 'js', 'ajax_download.js'))
  end

  def js_ajax_post
    File.read(File.join(Wpxf.data_directory, 'js', 'ajax_post.js'))
  end

  def start_http_server
    server = TCPServer.new(http_server_bind_address, http_server_bind_port)
    emit_info "Started HTTP server on #{http_server_bind_address}:"\
              "#{http_server_bind_port}"

    begin
      loop do
        socket = server.accept

        response = handle_incoming_http_request(socket)
        if response
          socket.print "HTTP/1.1 200 OK\r\n"\
                       "Content-Type: text/plain\r\n"\
                       "Content-Length: #{response.bytesize}\r\n"\
                       "Connection: close\r\n"
          socket.print "\r\n"
          socket.print response
        end

        socket.close
        break if @http_server_kill_switch
      end
    rescue SignalException
      emit_warning 'Caught kill signal', true
    end

    server.close
    emit_info 'HTTP server stopped'
    @http_server_kill_switch = false
  end

  def stop_http_server
    emit_info 'Stopping HTTP server...', true
    @http_server_kill_switch = true
  end

  private

  def handle_incoming_http_request(socket)
    request = socket.gets
    if request
      emit_info "Incoming HTTP request: #{request}", true

      headers = ''
      while (line = socket.gets) != "\r\n"
        headers += line
        emit_info line, true
      end

      headers = Hash[headers.each_line.map { |l| l.chomp.split(': ', 2) }]
      path = request.gsub(/^[A-Za-z]+\s(.+?)\s.*$/, '\1').chomp
      params = {}

      if path.include?('?')
        params = CGI.parse(path.split('?')[-1])
        params.each do |k, v|
          params[k] = v.join(' ')
        end
        path = path.split('?')[0]
      end

      # Dispatch parsed data to the callback in the module.
      on_http_request(path, params, headers)
    end
  end
end
