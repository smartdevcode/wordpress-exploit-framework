require 'fileutils'

module Wpxf
  module Utility
    # A super strong body builder capable of building formatted form bodies for
    # use with the {Wpxf::Net::HttpClient} mixin.
    class BodyBuilder
      def initialize
        @fields = {}
        @temp_dir = File.join(Dir.tmpdir, "wpxf_#{object_id}")
      end

      # Add a key-value pair to the field list.
      # @param name the name of the form item.
      # @param value the value of the form item.
      # @return [Hash] the newly added form item.
      def add_field(name, value)
        @fields[name] = { type: :normal, value: value }
        @fields[name]
      end

      # Add a file to the field list.
      # @param name the name of the form item.
      # @param path the local path of the file to be uploaded.
      # @param [optional] remote_name the file name to transmit the file as.
      # @return [Hash] the newly added form item.
      def add_file(name, path, remote_name = nil)
        @fields[name] = { type: :file, path: path, remote_name: remote_name }
        @fields[name]
      end

      # Add a file to the field list that will upload a specific string as its
      # file contents, rather than reading from disk.
      # @param name the name of the form item.
      # @param value the contents of the file.
      # @param remote_name the file name to transmit the file as.
      # @return [Hash] the newly added form item.
      def add_file_from_string(name, value, remote_name)
        @fields[name] = {
          type: :mem_file,
          value: value,
          remote_name: remote_name
        }
        @fields[name]
      end

      # Creates the body string and passes it to the block given to the
      # call to {#create}.
      # @yieldparam body the {Wpxf::Net::HttpClient} compatible body string.
      # @return [Nil] nothing, the body must be accessed by using
      #    a block when calling the method.
      def create
        normal_fields = create_normal_fields
        file_fields = create_file_fields
        mem_file_fields = create_mem_file_fields
        body = normal_fields.merge(file_fields.merge(mem_file_fields))
        yield(body)
        cleanup_temp_files(body)
        nil
      end

      private def cleanup_temp_files(fields)
        fields.each do |_k, v|
          v.close if v.is_a?(File)
        end

        FileUtils.rm_rf "#{@temp_dir}"
      end

      private def create_tmp_directory(name)
        directory = File.join(@temp_dir, name)
        FileUtils.mkdir_p(directory)
        directory
      end

      private def copy_file_to_temp_path(src, dest, parent_name)
        directory = create_tmp_directory(parent_name)
        temp_path = File.join(directory, dest)
        FileUtils.cp(src, temp_path)
        temp_path
      end

      private def create_tmp_file_from_string(content, dest, parent_name)
        path = File.join(create_tmp_directory(parent_name), dest)
        File.open(path, 'w') { |f| f.write(content) }
        path
      end

      private def create_normal_fields
        fields = {}
        @fields.select { |_k, v| v[:type] == :normal }.each do |k, v|
          fields[k] = v[:value]
        end
        fields
      end

      private def create_mem_file_fields
        fields = {}
        @fields.select { |_k, v| v[:type] == :mem_file }.each do |k, v|
          path = create_tmp_file_from_string(v[:value], v[:remote_name], k)
          fields[k] = File.open(path, 'r')
        end
        fields
      end

      private def create_file_fields
        fields = {}
        @fields.select { |_k, v| v[:type] == :file }.each do |k, v|
          unless v[:remote_name].nil?
            v[:path] = copy_file_to_temp_path(v[:path], v[:remote_name], k)
          end

          fields[k] = File.open(v[:path], 'r')
        end
        fields
      end
    end
  end
end
