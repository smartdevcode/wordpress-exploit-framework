module Cli
  # A context which modules will be used in.
  class Context
    def initialize
    end

    def class_name(path_name)
      return path_name if path_name !~ /_/ && path_name =~ /[A-Z]+.*/
      path_name.split('_').map(&:capitalize).join
    end

    def verbose?
      self.module.normalized_option_value('verbose')
    end

    def load_module(path)
      match = path.match(/(auxiliary|exploit)\/(.+)/i)
      fail 'Invalid module path' unless match

      type = match.captures[0]
      name = class_name(match.captures[1])

      begin
        if type.eql? 'auxiliary'
          @module = Wpxf::Auxiliary.const_get(name).new
        elsif type.eql? 'exploit'
          @module = Wpxf::Exploit.const_get(name).new
        end
      rescue NameError
        raise 'Invalid module name'
      end

      @module_path = path
      @module
    end

    def reload
      if @module_path =~ /^exploit\//i
        load("#{@module_path.sub('exploit/', 'exploits/')}.rb")
      else
        load("#{@module_path}.rb")
      end

      load_module(@module_path)
    end

    def load_payload(name)
      clsid = class_name(name)

      if Wpxf::Payloads.const_defined?(clsid)
        payload_class = Wpxf::Payloads.const_get(clsid)
        if payload_class.is_a?(Class)
          self.module.payload = payload_class.new
        else
          fail "\"#{name}\" is not a valid payload"
        end
      else
        fail "\"#{name}\" is not a valid payload"
      end

      self.module.payload
    end

    attr_reader :module_path
    attr_reader :module
  end
end
