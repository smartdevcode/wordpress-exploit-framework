module Cli
  # Methods for handling commands that interact with modules.
  module Modules
    def reload
      unless context
        print_bad 'No module loaded yet'
        return
      end

      begin
        mod = context.reload
        mod.event_emitter.subscribe(self)
        print_good "Reloaded module: #{mod}"
      rescue StandardError => e
        print_bad "Failed to reload module: #{e}"
      end

      # Set any globally set options.
      @global_opts.each do |k, v|
        set_option_value(k, v, true)
      end
    end

    def use(module_path)
      context = Context.new
      begin
        mod = context.load_module(module_path)
        mod.event_emitter.subscribe(self)
        print_good "Loaded module: #{mod}"
        @context_stack.push(context)
      rescue StandardError => e
        print_bad "Failed to load module: #{e}"
      end

      # Set any globally set options.
      @global_opts.each do |k, v|
        set_option_value(k, v, true)
      end

      refresh_autocomplete_options
    end

    def info
      print_std("       Name: #{context.module.module_name}")
      print_std("     Module: #{context.module_path}")
      print_std("  Disclosed: #{context.module.module_date}")

      puts ''
      print_std('Provided by:')
      indent_cursor do
        context.module.module_author.each do |author|
          print_std("#{author}")
        end
      end

      puts ''
      show_options

      puts ''
      print_std('Description:')
      indent_cursor do
        print_std(wrap_text(context.module.module_desc))
      end
      puts ''

      if context.module.module_references
        print_std('References:')
        indent_cursor do
          context.module.module_references.each do |ref|
            if ref[0].eql? 'WPVDB'
              print_std("https://wpvulndb.com/vulnerabilities/#{ref[1]}")
            elsif ref[0].eql? 'OSVDB'
              print_std("http://www.osvdb.org/#{ref[1]}")
            elsif ref[0].eql? 'CVE'
              print_std("http://www.cvedetails.com/cve/#{ref[1]}")
            elsif ref[0].eql? 'EDB'
              print_std("https://www.exploit-db.com/exploits/#{ref[1]}/")
            else
              print_std(ref[1])
            end
          end
        end
      end
    end

    def check
      if context && context.module
        state = context.module.check

        if state == :vulnerable
          print_warning 'Target appears to be vulnerable'
        elsif state == :unknown
          print_bad 'Could not determine if the target is vulnerable'
        else
          print_good 'Target appears to be safe'
        end
      else
        print_warning 'No module loaded'
      end
    end

    def search(*args)
      pattern = /#{args.map { |m| Regexp.escape(m) }.join('|')}/i
      module_list = Wpxf::Auxiliary.module_list + Wpxf::Exploit.module_list

      results = []
      module_list.select { |m| m =~ pattern }.each do |path|
        context = Context.new
        context.load_module(path)
        results.push(path: path, title: context.module.module_name)
      end

      if results.length > 0
        print_good "#{results.length} Results for \"#{args.join(' ')}\""
        results = results.sort_by { |k| k[:path] }
        results.unshift(path: 'Module', title: 'Title')
        puts ''
        indent_cursor 2 do
          print_table(results)
        end
      else
        print_bad "No results for \"#{args.join(' ')}\""
      end
    end

    def run
      unless context
        print_warning 'No module loaded'
        return
      end

      mod = context.module
      unless mod.can_execute?
        opts = mod.missing_options.join(', ')
        print_bad "One or more required options not set: #{opts}"
        return
      end

      if mod.payload && !mod.payload.prepare(mod)
        print_bad 'Failed to prepare the payload'
        return
      end

      begin
        if mod.run && (!mod.payload || mod.payload.post_exploit(mod))
          print_good 'Execution finished successfully'
        else
          print_bad 'Execution failed'
        end
      rescue StandardError => e
        print_bad "Uncaught error: #{e}"
        print_bad e.backtrace.join("\n\t")
        puts ''
        print_bad 'Execution failed'
      end

      mod.cleanup
    end
  end
end
